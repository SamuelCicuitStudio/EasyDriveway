What’s inside

EspNowStack.h — the only header you include from app code. Declarations only: stack facade, deps/settings structs, callback interface, and function signatures (no bodies).

core/espnow_core.cpp

core/espnow_router.cpp

core/espnow_scheduler.cpp

transport/espnow_radio.cpp

codec/codec_header_auth.cpp

codec/codec_build_control.cpp

codec/codec_build_reports.cpp

codec/codec_build_fw.cpp

security/security_hmac.cpp

topology/topo_store.cpp

topology/topo_tlv.cpp

topology/topo_token.cpp

fw/fw_update.cpp

roles/role_icm.cpp (includes Hardware_ICM.h)

roles/role_pms.cpp (includes Hardware_PMS.h)

roles/role_rel.cpp (includes Hardware_REL.h)

roles/role_remu.cpp (includes Hardware_REMU.h)

roles/role_sens.cpp (includes Hardware_SENS.h)

roles/role_semu.cpp (includes Hardware_SEMU.h)

config/espnow_config.cpp

util/util_bytes.cpp

util/util_time.cpp

---

Great question. Here’s the order I recommend—and exactly what to implement first—for the **common**, role-agnostic parts. If you get these done, any role adapter can plug in and work.

# Start with these shared modules (in this order)

1. **util/**

   - `util_bytes.cpp`

     - ByteSpan helpers, LE read/write, bounds checks, CRC16 (for FW chunks).
     - Why first: used by codec, FW, and security everywhere.

   - `util_time.cpp`

     - Millis/epoch helpers, 48-bit nonce generator/validator (monotonic window).
     - Why first: security HMAC and header stamping need it.

2. **transport/**

   - `espnow_radio.cpp`

     - Thin wrapper over ESP-NOW: peer add/remove (encrypted), send(), RX callback up to the stack, channel set/get.
     - Why now: everything builds on reliable send/receive.

3. **security/**

   - `security_hmac.cpp`

     - Key derivation stubs, HMAC build/verify over `Header||Auth||[Topo?]||Payload||Nonce`, replay/nonce window per peer, privileged-op check (ICM+ICMMAC).
     - Why now: codec and router will call this to accept/reject frames.

4. **codec/**

   - `codec_header_auth.cpp`

     - Build/parse `NowHeader`, `NowAuth128`, `NowSecTrailer`, optional `NowTopoToken128`. Size guards for all structs (assert v2H sizes).

   - `codec_build_control.cpp`

     - Builders for `PING`, `CONFIG_WRITE`, `CTRL_RELAY`, `NET_SET_CHAN`, `TIME_SYNC`.

   - `codec_build_reports.cpp`

     - Builders/parsers for `SENS_REPORT`, `RLY_STATE`, `PMS_STATUS`.

   - `codec_build_fw.cpp`

     - Builders/parsers for `FW_*`.

   - Why now: gives the stack reliable, typed frames independent of roles.

5. **topology/**

   - `topo_store.cpp`

     - Holds current `topo_ver`, cached TLV blob; answers “does this opcode require a topo token?”.

   - `topo_tlv.cpp`

     - TLV parse/auth check for `TOPO_PUSH` (HMAC or signature item).

   - `topo_token.cpp`

     - Derive/validate `NowTopoToken128` bound to `topo_ver` + target.

   - Why now: `CTRL_RELAY` must enforce topology auth for all roles.

6. **core/**

   - `espnow_scheduler.cpp`

     - TX queues, per-opcode rate limits, retry policy, duplicate suppression.

   - `espnow_router.cpp`

     - RX flow: parse → security verify → topo checks → call role adapter (pure virtual).

   - `espnow_core.cpp`

     - Public facade: `begin()`, `tick()`, and `send*()` that glue codec+security+transport.

   - Why now: this is the role-agnostic brain.

7. **config/**

   - `espnow_config.cpp`

     - Load `KIND__/ICMMAC/CHAN__/TOKEN_/PAIRED` (NVS) into `EspNowSettings`. No role logic here—just settings.

   - Why now: lets any role boot with the same stack.

> You can leave **fw/** for a second pass if time-boxed. The rest already gives you pairing, secure control, telemetry, and topology.

awesome—since the **first 7 layers** are in, here’s the **next build plan** in the same “what/why” style. It’s sequenced so you can ship a working system quickly, then harden it.

---

# 8. **security (finish)**

- `security_sign.cpp` (or extend `security_hmac.cpp`)

  - **What**: add a public `bool signHmac(const NowHeader&, const NowAuth128&, const NowTopoToken128* topo, const uint8_t* payload, uint16_t len, NowSecTrailer& out)` that computes and fills `out.tag` using the same KDF as verify.
  - **Wire-up**: call it in `core/espnow_core.cpp::encode_frame()` instead of zeroing the tag.
  - **Why now**: closes the only bring-up shortcut remaining; TX frames become verifiable.

- `security_topo_kdf.cpp` (optional now; needed by §10)

  - **What**: tiny derivation for:

    - TLV HMAC key (for `TOPO_PUSH` auth item),
    - per-command **Topology Token** key.

  - **API**:

    - `bool topoTlvVerify(uint16_t topo_ver, ByteSpan tlv, const uint8_t tag[16]);`
    - `bool topoTokenDerive(uint16_t topo_ver, uint8_t role, uint8_t virt, const uint8_t mac[6], NowTopoToken128& out);`

  - **Why**: lets `topo_tlv.cpp` and `topo_token.cpp` move from “presence check” to cryptographic validation.

---

# 9. **fw/**

- `fw/fw_update.cpp`

  - **What**: device-side FW state machine + storage hooks.

    - Slot mgmt (erase/append/seek), CRC16 check per chunk, digest accumulation, windowing, and signature verify on commit.

  - **Glue**:

    - Public entry points used by role adapters:

      - `fwBegin(const NowFwBegin&) -> bool`
      - `fwAcceptChunk(const NowFwChunk&, ByteSpan data) -> bool`
      - `fwCommit(const NowFwCommit&, ByteSpan sig) -> bool`
      - `fwAbort(const NowFwAbort&) -> bool`
      - `fwStatus(NowFwStatus&) -> void`

  - **Why now**: enables over-the-air updates; ICM can fully exercise the transport.

---

# 10. **topology (finish crypto)**

- `topology/topo_tlv.cpp` (upgrade)

  - **What**: replace the “has auth item” test with `security_topo_kdf::topoTlvVerify(...)`.
  - **Why**: authenticated topology becomes enforceable.

- `topology/topo_token.cpp` (upgrade)

  - **What**: compute expected token via `topoTokenDerive(...)` and compare to provided `NowTopoToken128`.
  - **Why**: `CTRL_RELAY` gating now truly binds to the last accepted topology.

---

# 11. **core (polish + features)**

- `core/espnow_scheduler.cpp` (v2)

  - **What**:

    - priority lanes (`URGENT` flag),
    - per-destination pacing (MAC+opcode buckets),
    - TX completion feedback (optional: `esp_now_register_send_cb`) for smarter retry.

  - **Why**: smoother radio under load (FW + reports + control).

- `core/espnow_router.cpp` (v2)

  - **What**:

    - add **strict length** checks for variable payloads (`CONFIG_WRITE`, `FW_*` data),
    - privileged-gating macro (drop early unless `(ICM,ICMMAC)`),
    - expose counters (len_mismatch, auth_fail, replay_drop…) to role adapters.

  - **Why**: defense in depth & observability.

- `core/espnow_core.cpp` (v2)

  - **What**:

    - call `security_sign(...)` during frame build,
    - add `sendTo(const uint8_t dst[6], …)` overloads so ICM can talk to any node,
    - expose `setTopoVersion(uint16_t)` for ICM after `TOPO_PUSH` acceptance.

  - **Why**: generalizes TX routing and finishes signing.

---

# 12. **pairing**

- `roles/common/pairing.cpp` (role-agnostic helper)

  - **What**:

    - Device side: emit `PAIR_REQ` (unencrypted) at 1 Hz until paired,
    - ICM side: upon “approve”, derive LMK, add encrypted peer, send `PAIR_ACK` with token+channel,
    - persist: `TOKEN_`, `CHAN__`, `PAIRED` via `NvsManager`.

  - **Why**: gets new devices onboarded without manual flashing secrets.

- `transport/espnow_radio.cpp` (minor)

  - **What**: expose `radio_add_encrypted_peer(...)` already present—call it from ICM on approval.
  - **Why**: finish the loop.

---

# 13. **roles/**

Implement the minimal adapter for each role. Each file only knows its hardware headers and consumes the **stack callbacks**.

- `roles/role_icm.cpp` (includes `Hardware_ICM.h`)

  - **What**:

    - Implement all admin handlers: `PAIR_ACK`, `TOPO_PUSH` build, `NET_SET_CHAN`, `TIME_SYNC`, FW sender loop (uses scheduler).
    - UI hooks (optional): pairing approval, topology editor, FW progress.

  - **Why**: controller becomes authoritative.

- `roles/role_rel.cpp` (includes `Hardware_REL.h`)

  - **What**:

    - `onCtrlRelay()` → drive relays w/ interlocks + temps; reply `RLY_STATE`.
    - `onPing()` → `PING_REPLY`.

  - **Why**: end-to-end actuation.

- `roles/role_remu.cpp` (includes `Hardware_REMU.h`)

  - **What**:

    - Map `virt_id` + `channel` to virtual bitset; mimic `role_rel` behavior; emit `RLY_STATE`.

  - **Why**: lab testing without wiring.

- `roles/role_sens.cpp` (includes `Hardware_SENS.h`)

  - **What**:

    - Periodic `SENS_REPORT` builder (TF-Luna + ENV), cadence smoothing, presence bits.

  - **Why**: real telemetry path.

- `roles/role_semu.cpp` (includes `Hardware_SEMU.h`)

  - **What**:

    - Generate synthetic sensor streams (e.g., scripted presence); same report encoder.

  - **Why**: reproducible tests.

- `roles/role_pms.cpp` (includes `Hardware_PMS.h`)

  - **What**:

    - Telemetry encoder (`PMS_STATUS`), rate control; accept safe `CONFIG_WRITE` keys for rails/limits.

  - **Why**: close the loop on power.

---

# 14. **config (expand)**

- `config/espnow_config.cpp` (v2)

  - **What**:

    - load **LMK/PMK/SALT** if present,
    - expose `bool loadPeerKeysFor(const uint8_t mac[6], LmkPmk& out);` used by ICM pairing tool,
    - optional: read debug flags (LED/buzzer throttle, logging level).

  - **Why**: key hygiene + better boot config.

---

# 15. **diagnostics & tools**

- `util/util_diag.cpp`

  - **What**: counters registry (auth_fail, replay_dropped, etc.) with getters; optional `CONFIG_WRITE` key to dump/clear.
  - **Why**: field debugging without a debugger.

- `tools/host_loopback.cpp` (desktop only)

  - **What**: inject frames into router, capture TX from scheduler → fuzz sizes, random nonces, duplicate sequences.
  - **Why**: test harness without radios.

---

# 16. **QA: conformance & soak tests**

- **Conformance** (unit + integration)

  - Size checks for every wire struct.
  - HMAC positive/negative tests (wrong nonce, wrong token, modified payload).
  - Topology: reject `CTRL_RELAY` without token; accept with correct token; reject after topo bump until new token is used.
  - FW: bad CRC chunk → not advancing `next_needed`; final digest mismatch → ERROR.

- **Soak**

  - Mixed traffic: `SENS_REPORT` @ 10 Hz, periodic `PING`, sporadic `CTRL_RELAY`, and `FW_CHUNK` bursts; verify scheduler keeps latency bounded and loss acceptable.

---

## Quick win backlog (can be parallelized)

- Add `radio_send_cb` hookup to track delivery (stats + adaptive retry).
- Expose `sendTo(mac,…)` in the public facade for ICM fan-out sends.
- Add **NVS durability** for `topo_ver` and TLV cache (persist on `TOPO_PUSH` accept).
- Add **time source selection** in `util_time` (RTC vs millis) with graceful fallback.
- CLI-ish debug over serial: dump peers, channel, keys (masked), counters.

---

## When you’re ready, I can:

- add `security_sign(...)` + wire it into `encode_frame()`,
- upgrade topology to use real HMAC/SIG,
- scaffold the **role adapters** with skeleton handlers matched to your hardware headers,
- and drop a tiny **host_loopback** to run fast regressions without ESP32.
