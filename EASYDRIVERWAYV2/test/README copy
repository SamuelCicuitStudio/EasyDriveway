# Optimized Specification for ESP-NOW Driveway Light Control System (Rev. C — Drop-In Fix)

## 1) System Overview

Distributed **ESP-NOW** network with six roles:

- **ICM** – Controller/time master/topology/web UI
- **PMS** – Power manager (source/rails/telemetry)
- **SENS** – Physical sensor node (TF-Luna pair + env)
- **REL** – Physical relay node (actuates lights)
- **SEMU** – **Sensor Emulator** (1 device ⇒ **N** virtual sensors)
- **REMU** – **Relay Emulator** (1 device ⇒ **M** virtual relays)

Build selects role with exactly one `#define NVS_ROLE_*`.

---

## 2) Hardware Architecture

### 2.1 Common Baseline

- **ESP32-S3**
- Protected 48 V→5 V supply (reverse-polarity protection)
- SPI NAND (MKDV8GIL-AST) reserved for logs/snapshots
- Fan (PWM), buzzer, onboard LED
- Unified SPI pinout for SD/NAND (role-agnostic)

### 2.2 Role-Specific

- **ICM**: DS3231 RTC, DS18B20, RGB LED
- **PMS**: DS18B20, ACS781 current sense (wall/batt), voltage dividers, relays for source/rail control
- **SENS**: **TF-Luna x2 over I²C (pair A/B)**, BME280, VEML7700
- **REL**: 2× relay outputs (direct drivers), DS18B20
- **SEMU**: TCA9548A mux ⇒ up to 8 TF-Luna _pairs_ (virtualize many sensors)
- **REMU**: 74HC595 ×2 ⇒ 16 outputs (SER/SRCLK/RCLK/OE/MR)

> Production nodes avoid mux/shift registers; emulators concentrate density for lab & stress tests.

---

## 3) Firmware Architecture

### 3.1 Central I²C Policy (Drop-In Fix)

- **All I²C ownership is centralized in `I2CBusHub`.**
- Two buses (ESP32 peripherals):

  - **SYS** ⇒ `TwoWire(0)` – system/primary (used by **TF-Luna**)
  - **ENV** ⇒ `TwoWire(1)` – environment/peripherals (BME280, VEML7700, etc.)

- Buses are brought up **once** by `I2CBusHub` (idempotent).
- **Drivers must NOT call `Wire.begin()` themselves.** They **bind** to the hub’s `TwoWire` and may adjust clock with `setClock()` only.

#### I2CBusHub API (as used)

- `bool bringUpSYS(uint32_t hz)` / `bool bringUpENV(uint32_t hz)`
- `TwoWire& busSYS()` / `TwoWire& busENV()` _(lazy ensure-init)_
- `bool isSYSReady() const` / `bool isENVReady() const`
- `static bool beginSYS(uint32_t hz)` / `static bool beginENV(uint32_t hz)`
- `static TwoWire& sys()` / `static TwoWire& env()`
- `static bool initializedSYS()` / `static bool initializedENV()`

**Pins** (`I2C_SYS_SDA_PIN`, `I2C_SYS_SCL_PIN`, `I2C_ENV_SDA_PIN`, `I2C_ENV_SCL_PIN`) and **default clocks** (`I2C_SYS_HZ`, `I2C_ENV_HZ`) are defined in platform headers. The hub owns the actual `begin()` calls.

### 3.2 TF-Luna Manager (Drop-In Fix)

- **`TFLunaManager`** now **receives an already-initialized `I2CBusHub`** (or uses the static hub) and **binds the SYS bus**:

  - No `begin(sda,scl)` inside `TFLunaManager`
  - Optional `wire->setClock(400 kHz)` (idempotent)

- Reads NVS for:

  - Pins (diagnostic only; **not** used to initialize)
  - Addresses: `TFL_A_ADDR_KEY`/`TFL_B_ADDR_KEY` (defaults `TFL_ADDR_A`/`TFL_ADDR_B`)
  - Presence gates: `TF_NEAR_MM_KEY` / `TF_FAR_MM_KEY` (`TF_*_MM_DEFAULT`)

- Provides:

  - `begin(fps_hz=100, continuous=true)` – configure both sensors (mode + frame rate + save)
  - `setEnable(bool)` – enable/disable pair
  - `setAddresses(uint8_t addrA, uint8_t addrB)` – change & persist
  - `setFrameRate(uint16_t fps_hz)` – set/save both
  - `readA/ readB/ readBoth` – `Sample{dist_mm, amp, temp_c_x100, ok}`
  - `isPresentA/B` – within `[near_mm, far_mm]`

- Uses Bud Ryerson **TFLI2C** (which relies on global `Wire`); the hub ensures **SYS ≡ Wire(0)** so the driver rides the correct peripheral.

> **Important:** This drop-in eliminates duplicate I²C bring-up and prevents bus contention. It aligns the TF-Luna path with the hub policy.

### 3.3 Role Selection & Files

- One of: `NVS_ROLE_ICM | NVS_ROLE_PMS | NVS_ROLE_SENS | NVS_ROLE_RELAY | NVS_ROLE_SEMU | NVS_ROLE_REMU`
- Common config in `NVSConfig.h` (strict **6-char** keys)
- Role configs: `Config_ICM.h`…`Config_REMU.h` for role-exclusive keys
- Hardware pins in `Hardware_*.h`
- Drivers in `/drivers`: TF-Luna, BME280, VEML7700, DS18B20, ACS781, DS3231, 74HC595, etc.
- Subsystems: `espnow/`, `time/`, `logger/`, `storage/`, `ui/`, `net/`

---

## 4) Persistence Model — **What each device remembers** (6-char keys only)

### 4.1 Common (non-ICM nodes)

- **ICM link/admission**

  - `ICMMAC` – controller MAC
  - `TOKEN_` – admission/token
  - `PAIRED` – 1/0
  - `CHAN__` – ESP-NOW channel

- **Identity**

  - `KIND__`, `DEVID_`, `HWREV_`, `SWVER_`, `BUILD_`, `DEFNAM`

- **Indicators**

  - `LEDDIS`, `BUZDIS`

> With these four (`ICMMAC`, `TOKEN_`, `PAIRED`, `CHAN__`), a node can **rejoin autonomously** after power-cycle.

### 4.2 SENS (Production)

- **Boundary sensors** in chain:

  - Prev: `PRVMAC`, `PRVTOK`
  - Next: `NXTMAC`, `NXTTOK`

- **Ordered relay lists**:

  - Forward/ahead: `POSRLS` (array/JSON; index = activation order)
  - Reverse/behind: `NEGRLS` (array/JSON)

- **Sensing & actuation**

  - `TFNMM`, `TFFMM` (near/far mm if role wants extra overrides)
  - `ALS_T0`, `ALS_T1`
  - `CONFMS`, `STOPMS`, `RLYONM`, `RLYOFF`, `LEADCT`, `LEADMS`

### 4.3 REL (Production)

- **Exact two boundary sensors**:

  - Side A: `SAMAC_`, `SATOK_`
  - Side B: `SBMAC_`, `SBTOK_`

- Optional partition: `SPLIT_`
- Actuation guard: `PULSMS`, `HOLDMS`, `INTRLC`, `RTLIMC`

### 4.4 SEMU (Sensor Emulator)

- Device-level:

  - `SCOUNT` (default 8)
  - Boundary fallbacks & ordered lists (same semantics as SENS):

    - `PRVMAC`/`PRVTOK`, `NXTMAC`/`NXTTOK`, `POSRLS`, `NEGRLS`

- **Per-virtual sensor i** _(each behaves as an independent SENS)_:

  - Token: `V%02uTOK` ⇒ `V01TOK…`
  - Prev neighbor: `P%02uMAC` / `P%02uTOK`
  - Next neighbor: `N%02uMAC` / `N%02uTOK`
  - Optional per-virtual relay lists by convention (JSON namespacing by `virt_id`) within `POSRLS`/`NEGRLS`.

### 4.5 REMU (Relay Emulator)

- Device-level:

  - `RCOUNT` (default 16)
  - Fallback boundaries: `SAMAC_`/`SATOK_`, `SBMAC_`/`SBTOK_`, `SPLIT_`

- **Per-virtual relay j** _(each behaves as an independent REL)_:

  - Token: `O%02uTOK` ⇒ `O01TOK…`
  - Boundaries: `A%02uMAC`/`A%02uTOK`, `B%02uMAC`/`B%02uTOK`

### 4.6 ICM (Controller)

- Registry & topology:

  - `SLMACS`, `S%02uMC`/`S%02uTK`, `R%02uMC`/`R%02uTK`, `P01MAC`/`P01TOK`
  - Authoritative topology: `TOPO__` (JSON; chains, neighbors, per-virtual mapping)

---

## 5) Network & Protocol

### 5.1 ESP-NOW Frame (binary)

Header: `proto_ver`, `msg_type`, `seq`, `node_id`, `role`, **`virt_id`** (`0xFF` if none), `flags`, `ts_ms`; payload; CRC16.

**Types**: `HELLO`, `HELLO_ACK`, `TOPO_PUSH`, `CTRL_RELAY`, `CTRL_SYS`, `SENS_REPORT`, `RLY_STATE`, `PMS_STATUS`, `TIME_SYNC`, `LOG_REQ`, `CONFIG`, `FAULT_REPORT`, `ACK`.

- `CTRL_RELAY` includes `virt_id` and the current **topology token**; endpoints **reject** mismatched tokens.
- `TOPO_PUSH` carries neighbor maps and lists; receiver writes NVS keys accordingly.

### 5.2 Reliability & Security

- ACK + retry windows (8/20/50 ms), RSSI guards, 1 s de-dupe window
- **Topology token** (16 B) rotated per topo push
- PMK/LMK peers; optional payload HMAC-32

---

## 6) Operating Modes

- **Auto** (SENS/SEMU): TF-Luna pair derives **direction**; activates **ordered** relay list `POSRLS` or `NEGRLS` with `LEADCT` (how many lights ahead) and `LEADMS` (step delay). Presence window comes from `TF_NEAR_MM_KEY`/`TF_FAR_MM_KEY` unless overridden.
- **Manual** (ICM Web): Pulse any REL/REMU (requires `virt_id` for emulators). Token check enforced.

---

## 7) Web Interface (ICM) — **Explicit Endpoints & UI Flows**

### 7.1 UI Sections

1. **Paired Devices**

   - Table: role, physical MAC, `virt_count` (SEMU/REMU), token excerpt, RSSI, last-seen, firmware
   - Actions: rename (`DEFNAM`), remove (unpair), view details, export device JSON

2. **Chain Builder**

   - Drag-and-drop **SENS/SEMU virtual sensors** and **REL/REMU virtual relays** onto lanes
   - For SEMU/REMU: one physical MAC visualized as **N/M virtual tiles** (`virt_id` labeled)
   - Save writes **ICM topology** `TOPO__` and pushes `TOPO_PUSH` to nodes (rotates token)

3. **Live View**

   - Direction indicators, active relays (timeline), per-sensor range/ALS, errors/faults
   - Manual pulse: select endpoint (role + `virt_id`), `PULSMS`, `HOLDMS`

4. **Network**

   - Channel, PMK/LMK status, peer table, HMAC status

5. **Logs**

   - Live console, filter by role/device, export to CSV/JSON

### 7.2 REST/WebSocket Endpoints

**Authentication**

- `POST /api/login` → `{token}` (ICM local PIN or admin creds)
- Header `Authorization: Bearer <token>`

**Devices & Registry**

- `GET /api/devices` → `[{mac, role, virt_count, paired, token, rssi, swver, hwrev, defnam}]`
- `GET /api/device/:mac` → full device record + stored NVS snapshot
- `DELETE /api/device/:mac` → unpair, clear ICM registry & revoke token

**Topology**

- `GET /api/topology` → current `TOPO__` JSON

  ```json
  {
    "chains": [
      {
        "id": "lane1",
        "sensors": [
          { "mac": "aa:..", "virt": 255 },
          { "mac": "bb:..", "virt": 1 }
        ],
        "relays": [
          { "mac": "cc:..", "virt": 255 },
          { "mac": "dd:..", "virt": 3 }
        ]
      }
    ],
    "tokens": { "epoch": 12, "value": "BASE64_16B" }
  }
  ```

- `POST /api/topology` (body = new `TOPO__`) → validates, rotates token, **pushes** `TOPO_PUSH` to all nodes, persists `TOPO__`

**SEMU/REMU virtualization**

- `GET /api/virtual/:mac` → `{role, count, items:[{virt_id, tok, neighbors...}]}`
- `POST /api/virtual/:mac` → set `SCOUNT` or `RCOUNT`; optionally patch per-virtual neighbors/tokens

**Manual Control**

- `POST /api/relay/pulse`

  ```json
  { "mac": "cc:..", "virt_id": 255, "ms": 250, "token": "BASE64_16B" }
  ```

  → Sends `CTRL_RELAY` with topology token. 403 if token mismatch.

**Sensing/Live**

- `GET /api/sensors` → latest `SENS_REPORT` snapshots (distance mm, amp, temp, ok, present)
- `WS /ws/live` → push stream: reports, relay state, PMS status, faults

**NVS Export/Import**

- `GET /api/nvs/:mac` → device keys dump
- `POST /api/nvs/:mac` → patch subset of keys (strict 6-char validation)

**Firmware**

- `GET /api/fw/versions` → available builds
- `POST /api/fw/ota` → `{targets:[mac...], version:"x.y.z"}` (stagger with ack & rollback policy)

---

## 8) Firmware Layout, Tasks & Queues — **Explicit**

**Core tasks (typical priorities, adjust to FreeRTOS config):**

- `radioTask` (prio 5): ESP-NOW RX/TX, ack/retry, HMAC, de-dupe
- `sensorTask` (prio 4): TF-Luna reads via **`I2CBusHub.busSYS()`**, env reads via **ENV**
- `actuatorTask` (prio 4): relay state machine, 74HC595 driver (REMU), direct GPIO (REL)
- `pmsTask` (prio 3): rails control, current/voltage sampling, fan PWM/throttle
- `timeTask` (prio 2): DS3231 sync, drift correction, time beacons
- `logTask` (prio 2): flash/NAND ring buffer, upload on demand
- `sysTask` (prio 1): NVS commit batching, LED/buzzer policy

**Queues/Timers**

- `qRadioIn`/`qRadioOut`: fixed-size frames; back-pressure with drops logged
- `qSenseOut`: `SENS_REPORT` objects (debounced/hysteresis applied)
- `qActCmd`: actuation commands (manual + auto)
- `tPresence`: periodic presence scan (fps-driven), rate adaptive
- `tLeadWalk`: sequencer for ordered relay activations (Auto mode)

**I²C binding (critical)**

- `I2CBusHub.bringUpSYS(I2C_SYS_HZ)` once in role init (ICM or SENS)
- `auto& W = I2CBusHub::sys();` or instance `hub->busSYS()`
- **Never** call `W.begin()` in drivers; **OK** to call `W.setClock(400000)`

**TFLunaManager usage**

```cpp
I2CBusHub hub;
hub.bringUpSYS(I2C_SYS_HZ);          // idempotent
TFLunaManager tfl(&nvs, &hub);       // bind SYS bus, no begin()
tfl.begin(100 /*fps*/, true /*cont*/);
TFLunaManager::Sample A,B;
uint16_t fps;
tfl.readBoth(A,B,fps);
bool present = tfl.isPresentA(A) || tfl.isPresentB(B);
```

---

## 9) Bring-Up & Validation (Step-by-Step)

1. **Pairing**

   - Pair non-ICM nodes; verify NVS keys:

     - `ICMMAC`, `TOKEN_`, `PAIRED=1`, `CHAN__`

2. **I²C**

   - Ensure `I2CBusHub` initializes SYS/ENV once (log `_didSYS/_didENV`)
   - Confirm **no driver calls `Wire.begin()`**

3. **SENS/TF-Luna**

   - NVS pins present for diagnostics only; addresses in `TFL_A_ADDR_KEY`/`TFL_B_ADDR_KEY`
   - Presence gates in `TF_NEAR_MM_KEY`/`TF_FAR_MM_KEY`
   - Read sanity: millimeters, amplitude, temperature ×100, `ok`

4. **Topology push**

   - Build minimal chain SENS→REL; save `TOPO__`; push
   - Check SENS persisted: `PRVMAC/PRVTOK`, `NXTMAC/NXTTOK`, `POSRLS`, `NEGRLS`
   - Check REL persisted: `SAMAC_/SATOK_`, `SBMAC_/SBTOK_`

5. **Emulators**

   - Set `SCOUNT`/`RCOUNT`
   - Verify **per-virtual**:

     - SEMU: `VxxTOK`, `PxxMAC/TOK`, `NxxMAC/TOK`
     - REMU: `OxxTOK`, `AxxMAC/TOK`, `BxxMAC/TOK`

6. **Manual pulses**

   - `POST /api/relay/pulse` with correct token & `virt_id`

7. **Auto mode**

   - Move target through lanes; confirm direction and **ordered activation** with `LEADCT/LEADMS`

8. **Token rotation**

   - Update chain; rotate token; send old command → expect **reject**

---

## 10) Migration Notes from Rev. A/B → Rev. C (this drop-in)

- **Removed**: any `Wire.begin(sda,scl)` in TF-Luna path.
- **Added**: binding to **`I2CBusHub` SYS** bus; optional `setClock(400 kHz)` only.
- **Kept**: strict **6-char** NVS keys; per-virtual **SEMU/REMU** memory.
- **Web UI**: now explicitly models SEMU/REMU as multiple draggable virtual endpoints with `virt_id`.

---

## 11) Concrete Data Shapes (no summary, explicit)

### 11.1 `TOPO__` (ICM)

```json
{
  "chains": [
    {
      "id": "lane-1",
      "sensors": [
        { "mac": "AA:BB:..:01", "virt": 255 },
        { "mac": "CC:DD:..:02", "virt": 1 }
      ],
      "relays": [
        { "mac": "EE:FF:..:03", "virt": 255 },
        { "mac": "11:22:..:04", "virt": 3 }
      ]
    }
  ],
  "tokens": { "epoch": 42, "value": "BASE64_16B" }
}
```

### 11.2 `SENS_REPORT`

```json
{
  "mac": "AA:BB:..:01",
  "virt_id": 255,
  "t_ms": 1283942,
  "a": { "mm": 742, "amp": 1182, "tc_x100": 2556, "ok": true, "present": true },
  "b": {
    "mm": 2134,
    "amp": 842,
    "tc_x100": 2571,
    "ok": true,
    "present": false
  },
  "fps": 100
}
```

### 11.3 Manual Pulse (web → ICM → node)

Request:

```json
{ "mac": "EE:FF:..:03", "virt_id": 255, "ms": 250, "token": "BASE64_16B" }
```

Result (`CTRL_RELAY`):

```json
{ "ok": true, "ts": 1699912345, "rssi": -55, "applied": true }
```

### 11.4 SEMU per-virtual write

```json
{
  "mac": "CC:DD:..:02",
  "role": "SEMU",
  "SCOUNT": 8,
  "virtual": [
    {
      "virt_id": 1,
      "V01TOK": "BASE64_16B",
      "P01MAC": "..",
      "P01TOK": "..",
      "N01MAC": "..",
      "N01TOK": ".."
    },
    {
      "virt_id": 2,
      "V02TOK": "BASE64_16B",
      "P02MAC": "..",
      "P02TOK": "..",
      "N02MAC": "..",
      "N02TOK": ".."
    }
  ]
}
```

### 11.5 REMU per-virtual write

```json
{
  "mac": "11:22:..:04",
  "role": "REMU",
  "RCOUNT": 16,
  "virtual": [
    {
      "virt_id": 3,
      "O03TOK": "BASE64_16B",
      "A03MAC": "..",
      "A03TOK": "..",
      "B03MAC": "..",
      "B03TOK": ".."
    }
  ]
}
```

---

## 12) Developer Checklist (Drop-In Compliance)

- [ ] `I2CBusHub` is the **only** module that calls `TwoWire.begin(...)`
- [ ] `TFLunaManager` binds SYS; no local I²C `begin`
- [ ] NVS keys are **≤6 chars**, exactly as listed
- [ ] SEMU/REMU per-virtual tokens & neighbors persisted with the `%02u` pattern
- [ ] `TOPO__` push rotates token; commands include token
- [ ] Web endpoints present & return explicit shapes above
- [ ] Tasks bound to queues; rate control tied to TF-Luna FPS
- [ ] Manual pulse honors `virt_id` (255 for physical nodes)

---
