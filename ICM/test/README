Quick summary — what each board sees, does, and needs
Sensor module (presence board)

What it “sees” (inputs)

Two lanes: Left and Right.
Each lane has two longitudinal points (A/B) → L-A/L-B and R-A/R-B.

Optional: ambient light (day/night), temp for health.

What it does (on-board logic)

For each lane, detects direction (A→B or B→A), speed (Δx/Δt), stop/resume, reversal.

Builds a wave schedule for the relays in its local section:

If moving → brief all-on then step “1-2-3” (forward) or “3-2-1” (reverse).

Holds when stopped, continues on resume; Left/Right lane waves are independent (split mode).

Talks to nearby sensors to propagate direction/speed headers (pre-arm downstream sections).

Sends time-stamped schedules directly to its relays (Left/Right channels separately).

What it expects from the ICM

Pairing → ESP-NOW peer entry + a 16-byte token for this sensor.

Zero-centered topology push (for this sensor):

sensIdx

neighbor sensors: hasPrev/prevIdx/prevMac/token, hasNext/nextIdx/nextMac/token

local relay map: neg[] = list of relays to the left (−1, −2, …); pos[] = to the right (+1, +2, …), each with {relayIdx, pos, relayMac, relayToken}

Timebase beacons so schedule timestamps line up.

Optional config (debounce windows, stop timeout, step timing clamps).

What it stores (NVS)

Its own sensIdx, neighbor info, and tokens.

neg[]/pos[] relay entries with MACs/tokens.

Tunables: confirm window, stop timeout, lane spacing, day/night thresholds.

What it sends (ESP-NOW)

To relays in neg[]/pos[]: authenticated schedule messages per channel (L/R) with {baseTs, steps[], ttl}.

To neighbor sensors: small wave headers (lane, dir, speed, ETA).

To ICM: health/telemetry (optional).

Minimum hardware

ESP32 module, 5–12 V in → 3V3 buck, ESD on sensor lines.

Either 4× digital Hall sensors (robust outdoors) or 4× ToF distance sensors (precise).
Layout: L-A/L-B and R-A/R-B; A↔B spacing ~25–50 cm (consistent across boards).

Ambient light sensor (ALS). Optional temp.

Status LEDs: RUN, TRG.

Relay module (boundary relay)

What it “sees” (inputs)

Boundary info from ICM: the two nearest sensors A and B around this relay, with their MACs/tokens.

Schedules from ICM or those two sensors only.

What it does (on-board logic)

Authenticates schedule messages (ICM master MAC present + valid token + sender is A or B).

Executes per-channel (Left/Right) step timelines relative to baseTs.

Queues/replaces schedules with newer-wins policy; independent L/R so two waves can cross.

Optional telemetry (temp, supply); watchdog turns outputs off if idle too long.

What it expects from the ICM

Pairing → relay token.

Relay boundary push:

myIdx

A-sensor: aSensIdx, aSensMac, aSensToken

B-sensor: bSensIdx, bSensMac, bSensToken

splitRule (only for backward compatibility if sender uses “+/-” side instead of L/R)

Timebase beacons for schedule timing.

What it stores (NVS)

Its relay token, A/B sensor MACs + tokens, split rule.

Output mode/pins, PWM enable (if DC LED), watchdog.

What it accepts (ESP-NOW)

Schedules per channel: {relayIdx, baseTs, ch:"L"|"R", steps[], ttl}
(or legacy side:+/- mapped to L/R via splitRule).

Minimum hardware

ESP32 module, 5–24 V in → 3V3 buck, supply protection.

Two output channels:

DC LED: MOSFET drivers (optionally PWM).

AC: SSR/triac modules.

Per-channel fusing recommended; TVS/flyback as needed.

Status LEDs: RUN, L, R. Optional temp/current sensing.

How ICM manages both

Pairing & tokens: ICM is the only authority that pairs peers and issues tokens.

Topology:

Pushes zero-centered sensor records to each sensor (neighbors + local relays).

Pushes boundary records to each relay (A/B sensors + split rule).

Timebase: periodic beacons keep sensors/relays aligned for schedule timestamps.

Persistence: ICM saves topology to NVS; devices save their slices to NVS for cold-boot continuity.

APIs:

/api/peers/list (diagnostics),

/api/topology/set|get (JSON),

/api/export|import (full device snapshot).

At-a-glance: responsibilities
Thing Sensor module Relay module ICM
Pairing & tokens receives receives issues & manages
Topology source of truth consumes consumes maintains & pushes
Direction/speed, stop/resume computes n/a n/a
Build wave schedule yes executes n/a
Split-lane (L/R) yes (per-lane) yes (per-channel) n/a
Timebase consumes consumes broadcasts
Persistence local slice local slice full topo/export

That’s the compact picture. If you want, I can turn this into two one-page PDFs for installers (hardware wiring + commissioning steps) and one for firmware devs (packet fields & state machines).
